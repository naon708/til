## エイリアス

```bash
alias ls='ls -F'
type ls
#=> ls is aliased to 'ls -F'

unalias ls
```

### エイリアスを無効化して実行する方法

```bash
/bin/ls

command ls

\ls
```

## bashオプション

```bash
set -o ignoreeof
set +o ignoreeof
```

```bash
shopt -s cdspell
shopt -u cdspell
```

## シェル変数

```bash
# スペースは付けない(スペースを付けるとコマンドとして認識されてしまう)
var='test variables'
echo $var
```

### プロンプトのカスタマイズ

```bash
# 「Prompt String 1」の略称でプロンプト文字列を表す環境変数
PS1='[\u@\h \w] \$'
```

### パスを通す

```bash
# ~/binというディレクトリを検索パスの最後に追加する
PATH="$PATH:~/bin"
```

- PATHにはディストリビューションごとに適切な値があらかじめ設定されている
- インストールしたアプリケーションや自作ディレクトリを検索パスに含めたい場合に行う

### 定番のシェル変数

```bash
PATH LANG HOME PWD SHELL
```

## バックスラッシュがうまく打てなかった

- `option + ¥`だと打てなくて、`¥`のみ入力で打てた

## 環境変数

### 前提

- コマンドには外部コマンドと組み込みコマンドがある
- 外部コマンド：ファイルシステム上に実行ファイルとして存在するコマンド(`/bin/cat`など)
- 組み込みコマンド：シェルに内蔵されているコマンド(`echo`など)
- typeコマンドで確認できる

### シェル変数の参照

- 外部コマンドはシェル変数を参照できない
- 環境変数を設定することで外部コマンドから参照できるようになる

```bash
LANG=en_US.UTF-8
cat --help
#=> 英語で表示される
```

- catコマンド実行→環境変数の値をチェック→その設定に従って動作

```bash
# 環境変数一覧表示
printenv
```

```bash
# シェル変数LESSを環境変数として設定する例
export LESS='--no-init'
```

## bashの設定ファイル

```bash
# ログインシェルで起動したときに読み込まれる順番
/etc/profile --> ~/.bash_profile --> ~/.bashrc

# 非ログインシェルの場合
~/.bashrc
```

- `/etc/profile` システム全体
- `~/.bash_profile` ユーザー個別 & ログイン時のみ読み込まれる
- `~/.bashrc` ユーザー個別 & bashを起動するたびに読み込まれる

### シェルのカスタマイズ

- 基本的に`~/.bashrc`に書けば良い


## ファイルパーミッション・スーパーユーザー

```bash
ls -l /bin/cat
-rwxr-xr-x. 1 root root 40 May 17 21:57 /bin/cat
```

- Linuxは1つのマシンへ複数のユーザーが同時にログインして操作することを前提として作られている
- そのため、ファイルへのアクセス権限の仕組みが用意されている
- アプリケーションをインストールしたり、自作でシェルスクリプトを作成する際に必要になる概念

### グループ

```bash
groups
=> wheel
```

- ユーザーをまとめた集まりのこと
- ユーザーは最低1つのグループに属し、複数のグループに属すことができる

```bash
# オーナー(ファイルの所有者), ファイルが属するグループ
root root
```

### ファイルのパーミッション

```bash
# ファイルタイプ ファイルモード(オーナー, グループ, その他ユーザー) 
-rwxr-xr-x.
```

### ディレクトリのパーミッション

| 記号 | 意味 |
| --- | --- |
| r | ディレクトリ配下のファイル一覧の取得 |
| w | ディレクトリ配下のファイル・ディレクトリの作成・削除 |
| x | ディレクトリに移動する |
- read権限がないとlsができない
- write権限がないとディレクトリ配下にファイル作成したり削除ができない
    - あるファイルが削除できるかどうかは、そのファイルではなく親ディレクトリのパーミッションで決まる
- execute権限がないとcdできない

## ファイルモードの変更

```bash
chmod a=rwx hello.txt
```

### シンボルモード

- 指定したパーミッションのみ変更したいときに使う

| 記号 | 意味 |
| --- | --- |
| u | オーナー |
| g | グループ |
| o | その他ユーザー |
| a | すべて |

| 記号 | 意味 |
| --- | --- |
| + | 権限を追加する |
| - | 権限を解除する |
| = | 指定した権限と同等にする |

### 数値モード

- 元のパーミッションに関わらず新しい権限を与えたいときに使う

| 意味 | 数字 |
| --- | --- |
| read | 4 |
| write | 2 |
| execute | 1 |

```bash
rwxr-xr-x  == 755
```

## スーパーユーザー

- すべてのファイルのrwxが可能
- スーパーユーザーでの操作は、Linuxのシステム自体を破壊し得る
- 基本的に一般ユーザーで操作し、必要なときのみスーパーユーザーで作業するのが良い

```bash
# スーパーユーザー用の環境に初期化してrootユーザーに切り替え(初期化しないと上手く動かない事がある)
su -
```

```bash
# 1つのコマンドだけスーパーユーザーで実行する
sudo cat /etc/shadow
```

### sudoコマンドの実行権限を与える

```bash
sudo visudo

[ユーザー名] ALL=(ALL) ALL
```

- visudoを使用するとファイルの上書き前に文法チェックが入るので、vimで直接編集するより安全

## ターミナルマルチプレクサ

```bash
sudo yum install tmux
tmux
```

- 1つの端末の中に仮想的な端末を作成して管理するためのアプリケーション
- シェルを複数同時に起動して作業できる


## プロセスとは

- コマンドの実体はディスク上に保存された実行ファイルである
- ディスク上の実行ファイルをLinuxカーネルが読み出す→メモリに格納する→CPUがプログラムを実行する
- メモリ上で実行状態のプログラムのことを**プロセス**という

```bash
ps
```

- プロセスは同時に実行されていてもすべて独立している
- プロセスは親子関係で成り立つ

```bash
# 現在のユーザーが実行しているすべてのプロセスを表示
# 別のターミナルや、デーモンプロセス(ターミナルに接続していないプロセス)を表示する
ps x

# プロセスの親子関係を表示
ps f

# すべてのユーザーが実行しているプロセスを表示
ps ax

# すべてのプロセスの詳細を表示
ps aux
```

- Linuxを起動してログイン直後の何も作業していない状態でも数十個のプロセスが動いている
- **Linuxではマルチタスク機能によって、複数のプロセスが同時に動作している**

## ジョブとは

- シェルから見た処理の単位(Linuxカーネルから見た処理の単位がプロセス)
- すべてのプロセスはプロセスIDで操作できるが、ユーザーはシェルから操作を行うためジョブ単位のほうが利便性が高いケースが多い

### ジョブを体験する

```bash
# bashのマニュアルを読む
man bash

# ジョブを停止する
Ctrl+z
```

```bash
# ジョブ一覧を表示
jobs
```

### ジョブをフォアグラウンドにする(対話状態に戻す)

```bash
fg

# ジョブ番号を指定
fg %1
```

### ジョブをバックグラウンドで実行する

```bash
# コマンドラインの末尾に「&」を追加
cp hello.txt hello2.txt &
```

## killコマンド

```bash
# ジョブ終了
kill %1
```

- killコマンドは厳密にはジョブ・プロセスを終了させるコマンドではなく、実行中のプロセスに対してシグナルを送信するコマンド

```bash
# 下記はすべて同じ意味
kill 4696
kill -TERM 4696
kill -15 4696
```

- Ctrl+ZやCtrl+Cもシグナルを送信するための操作

```bash
# シグナル一覧表示
kill -l
```

- SIGKILLはプロセスに渡されず、直接Linuxカーネルが処理する
- SIGKILLは終了に必要な処理を無視して強制終了するため使用には注意する
    - Railsでいうdeleteメソッドがコールバックを実行しないでデータを削除する感覚に近そう



