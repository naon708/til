## エイリアス

```bash
alias ls='ls -F'
type ls
#=> ls is aliased to 'ls -F'

unalias ls
```

### エイリアスを無効化して実行する方法

```bash
/bin/ls

command ls

\ls
```

## bashオプション

```bash
set -o ignoreeof
set +o ignoreeof
```

```bash
shopt -s cdspell
shopt -u cdspell
```

## シェル変数

```bash
# スペースは付けない(スペースを付けるとコマンドとして認識されてしまう)
var='test variables'
echo $var
```

### プロンプトのカスタマイズ

```bash
# 「Prompt String 1」の略称でプロンプト文字列を表す環境変数
PS1='[\u@\h \w] \$'
```

### パスを通す

```bash
# ~/binというディレクトリを検索パスの最後に追加する
PATH="$PATH:~/bin"
```

- PATHにはディストリビューションごとに適切な値があらかじめ設定されている
- インストールしたアプリケーションや自作ディレクトリを検索パスに含めたい場合に行う

### 定番のシェル変数

```bash
PATH LANG HOME PWD SHELL
```

## バックスラッシュがうまく打てなかった

- `option + ¥`だと打てなくて、`¥`のみ入力で打てた

## 環境変数

### 前提

- コマンドには外部コマンドと組み込みコマンドがある
- 外部コマンド：ファイルシステム上に実行ファイルとして存在するコマンド(`/bin/cat`など)
- 組み込みコマンド：シェルに内蔵されているコマンド(`echo`など)
- typeコマンドで確認できる

### シェル変数の参照

- 外部コマンドはシェル変数を参照できない
- 環境変数を設定することで外部コマンドから参照できるようになる

```bash
LANG=en_US.UTF-8
cat --help
#=> 英語で表示される
```

- catコマンド実行→環境変数の値をチェック→その設定に従って動作

```bash
# 環境変数一覧表示
printenv
```

```bash
# シェル変数LESSを環境変数として設定する例
export LESS='--no-init'
```

## bashの設定ファイル

```bash
# ログインシェルで起動したときに読み込まれる順番
/etc/profile --> ~/.bash_profile --> ~/.bashrc

# 非ログインシェルの場合
~/.bashrc
```

- `/etc/profile` システム全体
- `~/.bash_profile` ユーザー個別 & ログイン時のみ読み込まれる
- `~/.bashrc` ユーザー個別 & bashを起動するたびに読み込まれる

### シェルのカスタマイズ

- 基本的に`~/.bashrc`に書けば良い


## ファイルパーミッション・スーパーユーザー

```bash
ls -l /bin/cat
-rwxr-xr-x. 1 root root 40 May 17 21:57 /bin/cat
```

- Linuxは1つのマシンへ複数のユーザーが同時にログインして操作することを前提として作られている
- そのため、ファイルへのアクセス権限の仕組みが用意されている
- アプリケーションをインストールしたり、自作でシェルスクリプトを作成する際に必要になる概念

### グループ

```bash
groups
=> wheel
```

- ユーザーをまとめた集まりのこと
- ユーザーは最低1つのグループに属し、複数のグループに属すことができる

```bash
# オーナー(ファイルの所有者), ファイルが属するグループ
root root
```

### ファイルのパーミッション

```bash
# ファイルタイプ ファイルモード(オーナー, グループ, その他ユーザー) 
-rwxr-xr-x.
```

### ディレクトリのパーミッション

| 記号 | 意味 |
| --- | --- |
| r | ディレクトリ配下のファイル一覧の取得 |
| w | ディレクトリ配下のファイル・ディレクトリの作成・削除 |
| x | ディレクトリに移動する |
- read権限がないとlsができない
- write権限がないとディレクトリ配下にファイル作成したり削除ができない
    - あるファイルが削除できるかどうかは、そのファイルではなく親ディレクトリのパーミッションで決まる
- execute権限がないとcdできない

## ファイルモードの変更

```bash
chmod a=rwx hello.txt
```

### シンボルモード

- 指定したパーミッションのみ変更したいときに使う

| 記号 | 意味 |
| --- | --- |
| u | オーナー |
| g | グループ |
| o | その他ユーザー |
| a | すべて |

| 記号 | 意味 |
| --- | --- |
| + | 権限を追加する |
| - | 権限を解除する |
| = | 指定した権限と同等にする |

### 数値モード

- 元のパーミッションに関わらず新しい権限を与えたいときに使う

| 意味 | 数字 |
| --- | --- |
| read | 4 |
| write | 2 |
| execute | 1 |

```bash
rwxr-xr-x  == 755
```

## スーパーユーザー

- すべてのファイルのrwxが可能
- スーパーユーザーでの操作は、Linuxのシステム自体を破壊し得る
- 基本的に一般ユーザーで操作し、必要なときのみスーパーユーザーで作業するのが良い

```bash
# スーパーユーザー用の環境に初期化してrootユーザーに切り替え(初期化しないと上手く動かない事がある)
su -
```

```bash
# 1つのコマンドだけスーパーユーザーで実行する
sudo cat /etc/shadow
```

### sudoコマンドの実行権限を与える

```bash
sudo visudo

[ユーザー名] ALL=(ALL) ALL
```

- visudoを使用するとファイルの上書き前に文法チェックが入るので、vimで直接編集するより安全

## ターミナルマルチプレクサ

```bash
sudo yum install tmux
tmux
```

- 1つの端末の中に仮想的な端末を作成して管理するためのアプリケーション
- シェルを複数同時に起動して作業できる


## プロセスとは

- コマンドの実体はディスク上に保存された実行ファイルである
- ディスク上の実行ファイルをLinuxカーネルが読み出す→メモリに格納する→CPUがプログラムを実行する
- メモリ上で実行状態のプログラムのことを**プロセス**という

```bash
ps
```

- プロセスは同時に実行されていてもすべて独立している
- プロセスは親子関係で成り立つ

```bash
# 現在のユーザーが実行しているすべてのプロセスを表示
# 別のターミナルや、デーモンプロセス(ターミナルに接続していないプロセス)を表示する
ps x

# プロセスの親子関係を表示
ps f

# すべてのユーザーが実行しているプロセスを表示
ps ax

# すべてのプロセスの詳細を表示
ps aux
```

- Linuxを起動してログイン直後の何も作業していない状態でも数十個のプロセスが動いている
- **Linuxではマルチタスク機能によって、複数のプロセスが同時に動作している**

## ジョブとは

- シェルから見た処理の単位(Linuxカーネルから見た処理の単位がプロセス)
- すべてのプロセスはプロセスIDで操作できるが、ユーザーはシェルから操作を行うためジョブ単位のほうが利便性が高いケースが多い

### ジョブを体験する

```bash
# bashのマニュアルを読む
man bash

# ジョブを停止する
Ctrl+z
```

```bash
# ジョブ一覧を表示
jobs
```

### ジョブをフォアグラウンドにする(対話状態に戻す)

```bash
fg

# ジョブ番号を指定
fg %1
```

### ジョブをバックグラウンドで実行する

```bash
# コマンドラインの末尾に「&」を追加
cp hello.txt hello2.txt &
```

## killコマンド

```bash
# ジョブ終了
kill %1
```

- killコマンドは厳密にはジョブ・プロセスを終了させるコマンドではなく、実行中のプロセスに対してシグナルを送信するコマンド

```bash
# 下記はすべて同じ意味
kill 4696
kill -TERM 4696
kill -15 4696
```

- Ctrl+ZやCtrl+Cもシグナルを送信するための操作

```bash
# シグナル一覧表示
kill -l
```

- SIGKILLはプロセスに渡されず、直接Linuxカーネルが処理する
- SIGKILLは終了に必要な処理を無視して強制終了するため使用には注意する
    - Railsでいうdeleteメソッドがコールバックを実行しないでデータを削除する感覚に近そう

## 標準入力・標準出力・標準エラー出力

- 標準入出力チャネル・・・データの流れる道
- コマンドの入出力先を「標準入出力」という形で抽象化しているため、入出力先をユーザーが自由に指定できる

<img width="1156" alt="スクリーンショット 2023-06-01 23 27 00" src="https://github.com/naon708/til/assets/77439261/07f29faa-18f0-432e-a2fe-d1334d1cded1">


## リダイレクト

- 標準入出力先を変更する機能のこと

### 標準入力のリダイレクト

```bash
# 入力リダイレクトを使った書き方
cat < hello.txt

# ファイル指定での書き方
cat hello.txt
```

- catの本来の動作は「標準入力をそのまま標準出力する」
- ファイル指定できるのはcatコマンドの利便性を考慮した機能
- Linuxでコマンドを作る際は、ファイル指定ではなく標準入力から受け取る方法で作ったほうが汎用的で他のプログラムとの連携もしやすいのでそちらを推奨

### 標準出力のリダイレクト

```bash
# コマンドの実行結果をファイルに出力する
ls > ls_result.txt
```

### 標準エラー出力のリダイレクト

- 標準出力と標準エラー出力は別々のチャネルである

```bash
# 標準エラー出力のリダイレクトは「2>」を使う
ls /xxxxx 2> error.txt

# 同時に指定もできる
ls /xxxxx > list.txt 2> error.txt

# 標準出力と標準エラー出力をresult.txtにまとめてリダイレクト
ls /xxxxx > result.txt 2>&1
```

- `&1`の「1」はLinuxで定義されている標準入出力の数値
    - `&`はファイルディスクリプタ(File Descriptor)と呼ばれるOSで使用される仕組みのこと
    - プロセスが入出力先(ファイル、ディスプレイなど)にアクセスするための識別子

| 入出力チャネル | 割り当てられている数値 |
| --- | --- |
| 標準入力 | 0 |
| 標準出力 | 1 |
| 標準エラー出力 | 2 |

```bash
# 上書きではなく末尾に追加
echo hoge >> hoge.txt
```

### /dev/null

- データの破棄、出力の抑制(不要なメッセージの非表示)、動作テスト、入力の終了などに使われる特別なファイル
    - 入力先に指定しても何も内容を返さない
    - 出力先に指定してもどこにも保存されずに消える

**使用例**

```bash
# ルートディレクトリと存在しないディレクトリを指定
ls / /xxxx

# ルートディレクトリ配下の情報とエラーメッセージが両方出力される
/:
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

ls: cannot access '/xxxx': No such file or directory
```

```bash
# 標準出力先を/dev/nullにすると標準出力が消えてエラーのみ表示できる
ls / /xxxx > /dev/null

ls: cannot access '/xxxx': No such file or directory
```

```bash
# 標準エラー出力先を/dev/nullにすると標準エラー出力が消えて標準出力のみ表示できる
ls / /xxxx 2> /dev/null

/:
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```
- 「エラーメッセージだけ見たい」等の不要なログを非表示にしたい場合などに重宝する


